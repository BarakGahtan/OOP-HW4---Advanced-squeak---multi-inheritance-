Object subclass: #OOPObject	instanceVariableNames: 'superclassInstances'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPObject methodsFor: 'as yet unclassified' stamp: 'NC 9/3/2019 11:44'!definingInstance: aSymbol|classifyRes idx currentClass fatherTreeRes instance|	classifyRes:= self class classifyInheritedMethod: aSymbol.	((classifyRes='inaccessible') or:[classifyRes='ambiguous']) ifTrue:[^nil].	idx:=1.	self class superclasses do:[:p|		instance:= superclassInstances at:idx.		currentClass:=p parentClass.		(currentClass canUnderstand: aSymbol) ifTrue:[			^instance.		].		(currentClass superclass=OOPObject) ifTrue:[			fatherTreeRes:=  instance definingInstance: aSymbol.			(fatherTreeRes~=nil) ifTrue:[^fatherTreeRes].		].			idx:=idx+1.	].	^nil! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'NC 9/3/2019 11:08'!doesNotUnderstand: aMessage	|clientClass msgSelector classifyRes|	msgSelector:= aMessage selector.	clientClass:= thisContext client class.	classifyRes:=self class classifyInheritedMethod:msgSelector.	(classifyRes='public')ifTrue:[		aMessage sendTo:(self definingInstance: msgSelector). 		^self.				]. 	(classifyRes='protected') ifTrue:[		(clientClass=self class)ifTrue:[			aMessage sendTo:(self definingInstance: msgSelector). 			^self.					].				(clientClass superclass=OOPObject) ifTrue:[			(clientClass multInheritsFrom: (self class))ifTrue:[			aMessage sendTo:(self definingInstance: msgSelector).			^self.			].		].		self class throwSender: (clientClass name)								fails: msgSelector								inClass: (self class)								because: classifyRes.	].	(classifyRes='private')ifTrue:[		"only out class can do this method"		(clientClass=self class)ifTrue:[			aMessage sendTo:(self definingInstance: msgSelector). 			^self.					].		self class throwSender: (clientClass name)								fails: msgSelector								inClass: (self class)								because: classifyRes.	].	self class throwSender: (clientClass name)							fails: msgSelector							inClass: (self class)							because: classifyRes.! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'NB 8/30/2019 17:22'!initialize	^self initializeSupers postInitialize.! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'NB 8/30/2019 14:22'!initializeSupers	|parentsArray idx|	parentsArray := self class superclasses.	superclassInstances:= Array new: (parentsArray size).	idx:=1.	parentsArray do: [:p|		superclassInstances at:idx put:(p parentClass new).		idx:= idx+1.	].	! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'NB 9/1/2019 19:26'!postInitialize	^ self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OOPObject class	instanceVariableNames: 'superclasses'!!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/1/2019 21:47'!OriginSubclass:s instanceVarNames:i classVarNames:n poolDictionaries:d category:c	"creates derivated class from current class"	^(ClassBuilder new)		superclass: self		subclass: s		instanceVariableNames: i		classVariableNames: n		poolDictionaries: d		category: c! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/3/2019 19:37'!add: newElement toArray: anArray	|newArray idx|	newArray:= Array new:(anArray size+1).	(anArray isEmpty) ifTrue: [		newArray at:1 put:newElement.	]ifFalse:[		idx := 1.				newArray at: idx put: newElement.		anArray do:[:iter| newArray at:(idx+1) put:iter.			idx:=idx+1.].	].	^newArray.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/3/2019 18:50'!classifyInheritedMethod: aSymbol	|res pClass fatherTreeRes|	res:='undefined'.	superclasses do:	[:p|		pClass:= p parentClass.		(pClass canUnderstand: aSymbol) ifTrue:[			(res~='undefined') ifTrue:[^'ambiguous'].			(pClass superclass=OOPObject) ifTrue:			[				((pClass classifyInheritedMethod: aSymbol)='ambiguous') ifTrue:[^'ambiguous'].			].			res:= p inheritanceType.		]ifFalse:[			(pClass superclass = OOPObject) ifTrue: [				fatherTreeRes:=pClass  classifyInheritedMethod: aSymbol.				(((fatherTreeRes~='undefined') and: (res~='undefined')) or:(fatherTreeRes='ambiguous')) ifTrue:[^'ambiguous'].				((fatherTreeRes='protected') or: (fatherTreeRes='public')) ifTrue: [res:=p inheritanceType].				((fatherTreeRes='private') or: (fatherTreeRes='inaccessible')) ifTrue: [res:='inaccessible'].				]		]	].	^res.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/1/2019 22:36'!multInheritsFrom: aClass	|currentParentClass|	"if current class is OOPObject- aClass is not in superclasses"	(OOPObject=self) ifTrue:[^false].	"check if aClass is in superclasses of self"	superclasses do:	[:currentParent | 		currentParentClass:= currentParent parentClass.		(currentParentClass = aClass) ifTrue:[^true].		"aClass is not in direct parentClasses so we will check in  parent-parent recursive"		((currentParentClass superclass)= OOPObject) ifTrue:		[			(currentParentClass multInheritsFrom: aClass) ifTrue:[^true].		].		(currentParentClass inheritsFrom: aClass) ifTrue:[^true].				].	^false.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/3/2019 18:40'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	^self subclass: aSubclassName			parentClasses: (Array new:0)			instanceVariableNames:instVarNames 			classVariableNames: classVarNames 			poolDictionaries:poolDictionaries 			category: aCategoryName! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/1/2019 20:44'!subclass: aSubclassNameparentClasses: anArrayinstanceVariableNames:instVarNames classVariableNames: classVarNames poolDictionaries:poolDictionaries category: aCategoryName| derivedClass parentsArray newParent |	derivedClass:= OOPObject OriginSubclass:aSubclassName								instanceVarNames:instVarNames								classVarNames:classVarNames 								poolDictionaries:poolDictionaries 								category:aCategoryName.	(self=OOPObject) ifTrue:[		derivedClass instVarNamed: 'superclasses' put: anArray	]ifFalse: [ 		newParent:= OOPParent new.		newParent parentClass: self.		newParent inheritanceType: 'public'.		parentsArray:= self add: newParent toArray: anArray.		derivedClass instVarNamed: 'superclasses' put: parentsArray.			].	^derivedClass.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/1/2019 20:50'!superclasses	^superclasses! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'NB 9/1/2019 22:03'!throwSender: senderName fails: methodName inClass: receiverName because: reason| str |    str := senderName, ' cannot send ',methodName asString,' to ',receiverName,' because: ' ,reason.    AssertionFailure signal: str.! !Object subclass: #OOPParent	instanceVariableNames: 'parentClass inheritanceType'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPParent methodsFor: 'as yet unclassified' stamp: 'NB 8/26/2019 20:49'!inheritanceType	^inheritanceType! !!OOPParent methodsFor: 'as yet unclassified' stamp: 'NB 8/26/2019 20:48'!parentClass	^parentClass! !!OOPParent methodsFor: 'initialize-release' stamp: 'NB 8/26/2019 20:53'!inheritanceType: aString	inheritanceType:= aString! !!OOPParent methodsFor: 'initialize-release' stamp: 'NB 8/26/2019 20:55'!initialize	parentClass:=Object.	inheritanceType= 'public'! !!OOPParent methodsFor: 'initialize-release' stamp: 'NB 8/26/2019 20:52'!parentClass: aClass	parentClass:=aClass! !